* Introduction
:PROPERTIES:
:arg-header: :tangle no
:END:
Options multi calculator and plotter.


#+begin_src bash
  python3 main.py -p 
#+end_src

** Requirements
- pandas
- numpy
- sympy
- requests
- plotly
- dash
- dash_bootstrap_components
- dash_bootstrap_templates
* Code
** Setup.py
:PROPERTIES:
:header-args: :tangle setup.py
:END:
#+begin_src python :tangle no
  from distutils.core import setup
  setup(
      name="Plot Options",
      version="0.0.1",
      packages=['dash=1', 'plotly',
  	     'dash-bootstrap-components',
  	     'dash-core-components',
  	     'numpy',
  	     'sympy',
  	     'pandas']
      license="Private"
      long_description=open('code.org').read()
#+end_src
** Poetry
:PROPERTIES:
:arg-header: :tangle pyproject.toml
:END:
#+begin_src toml :tangle pyproject.toml
  [tool.poetry]
  name = "options calculator"
  version = "0.0.1"
  description = "Calculate Options prices, greeks, and plot them"
  authors = ["kamysheblid <kamysheblid@gmail.com>"]
  license = "LICENSE"
  readme = "code.org"

  [tool.poetry.dependencies]
  python = "^3.11"
  dash = "^2.14.2"
  dash-bootstrap-components = "^1.5.0"
  dash-bootstrap-templates = "^1.1.2"
  dash-core-components = "^2.0.0"
  numpy = "^1.26.3"
  plotly = "^5.18.0"
  pandas = "^2.1.4"
  sympy = "^1.12"

  [build-system]
  requires = ["poetry-core"]
  build-backend = "poetry.core.masonry.api"
  # requires = ["setup-tools>=61.0"]
  # build-backend = "setuptools.build_meta"
#+end_src
Keep track of 
** APIs
*** Binance API
:PROPERTIES:
:header-args: :tangle lib/binance.py
:END:
**** Imports
#+begin_src python
  """Author: Kamy

  This is the api code. It is for communicating with the binance server
  and getting information from them.

  Date Info: Must be in format YY/MM/DD HH:MM

  Time Info (for development): Binance wants time information in milliseconds since epoch. But
  datetime gives it in seconds. So there has to be some jiggering to fix
  that in communications with binance.

  Proxy Info: To set a proxy just do this in the shell 

  ```$ export ALL_PROXY=PROXY_HOST:PROXY_PORT``` 

  This program uses requests library which automatically uses
  environment proxies.
  """

  import logging
  import requests
  import json
  import time
  import datetime
  import numpy as np
  import pandas as pd
  import os
#+end_src
**** Logging
#+begin_src python
  import importlib
  if importlib.util.find_spec('icecream'):
      from icecream import ic
      ic.configureOutput(prefix=lambda: str(datetime.datetime.now()), includeContext=True)
  else:
      ic = print

  ## Logger Setup ##
  logger = logging.getLogger('binance-api')
  logging_config = {
      "version": 1,
      "disable_existing_loggers": False,
      # "filters": {...},
      # "formatters": {...},
      # "handlers": {...},
      # "loggers": {...}
  }
#+end_src
**** Global Variables
#+begin_src python
  ## Global Variables ##
  PROXY = {'all': '0.0.0.0:2081'}
  SITE = 'https://api.binance.com'
  DAY_DELTA = datetime.timedelta(days=1)
  INTERVALS = {'1s': datetime.timedelta(seconds=1),
               '1m': datetime.timedelta(seconds=60),
               '3m': datetime.timedelta(seconds=180),
               '5m': datetime.timedelta(seconds=300),
               '15m': datetime.timedelta(seconds=900),
               '30m': datetime.timedelta(seconds=1800),
               '1h': datetime.timedelta(seconds=3600),
               '2h': datetime.timedelta(seconds=7200),
               '4h': datetime.timedelta(seconds=14400),
               '6h': datetime.timedelta(seconds=21600),
               '8h': datetime.timedelta(seconds=28800),
               '12h': datetime.timedelta(seconds=43200),
               '1d': datetime.timedelta(days=1),
               '3d': datetime.timedelta(days=3),
               '1w': datetime.timedelta(days=7),
               '1M': datetime.timedelta(weeks=4)}
  SYMBOLS = None
#+end_src
**** Miscellaneous
#+begin_src python
  ## Miscellaneous ##
  def ping():
      '''Check to see if we can contact the server'''
      req = requests.get(SITE+'/api/v3/ping')
      if req.status_code != 200:
          raise Exception(f'Error: cannot contact the server: {req.status_code}')
      return True

  def get_symbols():
      '''Get an np.array of all symbols'''
      req = requests.get(SITE+'/api/v3/exchangeInfo')
      if req.status_code != 200:
          raise Exception(f"Error: contact with server failed:\t {req.status_code}")
      ic(req)
      return np.array([elt['symbol'] for elt in json.loads(req.text)['symbols']])

  def ensure_symbol(symbol):
      global SYMBOLS
      if SYMBOLS is None:
          SYMBOLS= get_symbols()
      if symbol not in SYMBOLS:
          raise Exception(f'Error: Symbol {symbol} not available')
      return True
#+end_src
**** Datetime Conversions and Checks
#+begin_src python
  def date_to_epoch(date):
      '''Date is in this format: YY/MM/DD HH:MM

      Example "24/06/26 14:50" returns epoch equivalent to
      datetime(2024, 6, 26, 14, 50) which is equal to 1719431520.0

      >>> date_to_epoch('20/01/01 12:00')
      1577867400.0
      '''
      return datetime.datetime.strptime(date, "%y/%m/%d %H:%M").timestamp()

  def datetime_to_milliseconds(date):
      '''Turns datetime object to milliseconds

      >>> datetime_to_milliseconds(datetime.datetime(2024,6,26,14,50))
      1719400800000
      '''
      return int(date.timestamp()*1000)

  def date_to_milliseconds(date): 
      '''Date is in this format: YY/MM/DD HH:MM

      >>> date_to_milliseconds("20/01/01 12:00")
      1577867400000.0

      >>> date_to_milliseconds("24/06/26 14:50") #equivalent to datetime(2024, 6, 26, 14, 50)
      1719431520000.0
      '''
      return date_to_epoch(date)*1000

  def milliseconds_to_datetime(ms):
      '''Data from binance is in milliseconds. Convert milliseconds to
      datetime object.

      >>> milliseconds_to_datetime(1719417832.0)
      datetime.datetime(2024, 6, 26, 19, 33, 50)
      '''
      seconds_to_epoch = int(ms/1000)
      return datetime.datetime.fromtimestamp(seconds_to_epoch)

  def ensure_interval(interval_string):
      '''
      == Interval must be one of the following ==
      seconds 	1s
      minutes 	1m, 3m, 5m, 15m, 30m
      hours 	1h, 2h, 4h, 6h, 8h, 12h
      days 	1d, 3d
      weeks 	1w
      months 	1M
      '''
      if interval_string not in INTERVALS.keys():
          raise Exception(f'Interval incorrect "{interval_string}"')
      return True

  import builtins
  def normalize_date_to_datetime(date):
      '''Get date and return a datetime object

      >>> normalize_date_to_datetime('24/6/10 10:00')
      datetime.datetime(2024, 6, 10, 10, 0)

      >>> normalize_date_to_datetime(int(normalize_date_to_datetime('24/6/10 10:00').timestamp())*1000)
      datetime.datetime(2024, 6, 10, 10, 0)

      >>> normalize_date_to_datetime(normalize_date_to_datetime('24/6/10 10:00').timestamp()*1000*1000)
      datetime.datetime(2024, 6, 10, 10, 0)
      '''
      match type(date):
          case datetime.datetime:
              return date
          # is in microseconds
          case builtins.float:
              return datetime.datetime.fromtimestamp(int(date/1000/1000))
          # is in milliseconds
          case builtins.int:
              return datetime.datetime.fromtimestamp(int(date/1000))
          case builtins.str:
              return datetime.datetime.strptime(date, '%y/%m/%d %H:%M')

  def ensure_dates(startTime, endTime, intervalString='1d'):
      '''Dates are auto-converted, function ensures they are less than
      1000 intervals apart

      >>> check_dates('24/01/01 00:00','22/01/01 00:00','1d')
      True

      >>> check_dates('24/01/01 00:00','20/01/01 00:00','1d')
      False
      '''
      if intervalString not in INTERVALS.keys():
          raise Exception(f'Error: interval is incorrect')

      startDate = normalize_date_to_datetime(startTime)
      endDate = normalize_date_to_datetime(endTime)
      if endDate - startDate > 1000*INTERVALS[intervalString]:
          maxStartDate = endDate - 1000*INTERVALS[intervalString]
          logger.error(f'startTime cannot be before {maxStartDate}')
          raise Exception('Error: Dates are too far apart.')
      return True
#+end_src
**** Main Methods
#+begin_src python
  def get_klines(symbol='ETHUSDT', interval='1d',
                 startTime=(datetime.datetime.now()-DAY_DELTA),
                 endTime=datetime.datetime.now(), timeZone='+3:30', limit=1000):
      '''get_klines(symbol, interval, startTime, endTime, timeZone, limit)
      == klines Parameters ==
      Name 	Type 	Mandatory 	Description
      symbol 	STRING 	YES 	
      interval 	ENUM 	YES 	
      startTime 	LONG 	NO 	
      endTime 	LONG 	NO 	
      timeZone 	STRING 	NO 	Default: 0 (UTC)
      limit 	INT 	NO 	Default 500; max 1000.'''

      ensure_interval(interval)
      startTime = normalize_date_to_datetime(startTime)
      endTime = normalize_date_to_datetime(endTime)
      ensure_dates(startTime, endTime)

      parameters = dict(symbol=symbol, interval=interval,
                        startTime=datetime_to_milliseconds(startTime),
                        endTime=datetime_to_milliseconds(endTime), timeZone=timeZone,
                        limit=limit)
      req = requests.get(SITE+'/api/v3/klines', params=parameters)

      if req.status_code == 200:
          return eval(req.text)
      else:
          code, msg = json.loads(req.text).values()
          raise Exception(f'Error code {code}: {msg}')

  PARSED_OUTPUT_COLUMNS = [('open time', datetime.datetime),
                           ('Open price', float),
                           ('High price', float),
                           ('Low price', float),
                           ('Close price', float),
                           ('Volume', float),
                           ('Close time', int),
                           ('Quote asset volume', float),
                           ('Number of trades', int),
                           ('Taker buy base asset volume', float),
                           ('Taker buy quote asset volume', float)]

  def parse_kline(kline):
      '''KLine data Input:
      [Kline open time, Open price, High price, Low price, Close price,
      Volume, Kline Close time, Quote asset volume, Number of trades,
      Taker buy base asset volume, Taker buy quote asset volume, Unused
      field, ignore.]

      KLine data Output:
      [Open time, Open price, High price, Low price, Close price,
      Volume]
      '''

      open_time = milliseconds_to_datetime(kline[0])
      open_price = kline[1]
      high_price = kline[2]
      low_price = kline[3]
      close_price = kline[4]
      volume = kline[5]
      close_time = kline[6]
      quote_volume = kline[7]
      num_of_trades = kline[8]
      taker_buy_base_asset_volume = kline[9]
      taker_buy_quote_asset_volume = kline[10]

      return np.array([open_time, open_price, high_price, low_price,
                       close_price, volume, close_time, quote_volume,
                       num_of_trades, taker_buy_base_asset_volume,
                       taker_buy_quote_asset_volume])

  def create_dataframe(dataList):
      '''Takes the data received from server and converts it into proper
      datatypes and returns DataFrame.

      Only the time needs to be converted.'''
      # Turn into np.array so I can use slices.
      dataArray = np.array(dataList)

      # Convert milliseconds from server into datetime objects
      open_time = pd.Series(data=[milliseconds_to_datetime(row[0]) for
                                  row in dataList], dtype='datetime64[ns]')
      return pd.DataFrame(data=dataArray[:,1:6], index=open_time,
                          columns=['Open', 'High', 'Low', 'Close',
                                   'Volume'], dtype=float)
#+end_src
**** Main
#+begin_src python
  def main(symbol='ETHUSDT', interval='1d', startDate=datetime.datetime.now()-1000*INTERVALS['1d'] , endDate=datetime.datetime.now(), number_of_intervals=1000):
      ensure_interval(interval)
      ensure_symbol(symbol)
      startTime = endDate - INTERVALS[interval]*number_of_intervals
      dataList = get_klines(symbol, interval, startTime=startTime, endTime=endDate, timeZone='00:00', limit=number_of_intervals)
      return create_dataframe(dataList)

  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+end_src
** TODO Dash Webpage
:PROPERTIES:
:header-args: :tangle plot.py
:END:
Uses plotly to display information on options. The user enters some
information on options like Strike, Time to Expiry, etc, and then it
is plotted.

TODO:
- Add multiple options to plotter
- Add date interval calculator
*** Imports
#+begin_src python
  import numpy as np
  import pandas as pd
  # Plotly and Dash Imports
  import plotly.express as px
  import plotly.graph_objects as go
  import plotly.io as pio
  from dash import Dash, dcc, html, Input, Output, callback, Patch, ALL, MATCH
  import dash_bootstrap_components as dbc
  import dash_bootstrap_templates as dbt

  # Import from local folder
  import options
  from lib import binance
#+end_src
*** Logger Init
Prepare the logger for using throughout the program
#+begin_src python  from icecream import ic
  import logging
  # Create logger and set level
  logger = logging.getLogger(__name__)
  logger.setLevel(logging.DEBUG)
  # Create console handler and set level
  ch = logging.StreamHandler()
  ch.setLevel(logging.DEBUG)
  # Create formatter
  formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
  # Add formatter to ch
  ch.setFormatter(formatter)
  # Add ch to logger
  logger.addHandler(ch)
#+end_src
*** Dash Init
#+begin_src python
  fig = go.Figure()
  app = Dash(__name__, external_stylesheets=[dbc.themes.MINTY, dbc.icons.FONT_AWESOME], title="Options Pricing")
#+end_src
*** Dash Components
**** Dark Mode Components                                          :darkmode:
***** Working Dark Mode
#+begin_src python
  dbt.load_figure_template(['minty_dark', 'minty'])

  color_mode_switch = dbt.ThemeSwitchAIO(aio_id='theme', themes=[dbc.themes.MINTY, dbc.themes.CYBORG], switch_props={'persistence': True})
#+end_src
***** Dark Mode Callbacks
****** CANCELLED Whole Page Dark Mode
CLOSED: [2024-01-15 Mon 21:36]
May be unnecessary since theme changer handles everything
#+begin_src python :tangle no
  clientside_callback("""(SwitchOn) => {
  SwitchOn
  ? document.documentElement.setAttribute('data-bs-theme', 'light')
  : document.documentElement.setAttribute('data-bs-theme', 'dark')
  return window.dash_clientside.no_update
  }""",
                      Output('color-mode-switch', 'id'),
                      Input('color-mode-switch', 'value'))
#+end_src
****** Plot Dark Mode
#+begin_src python
  @callback(Output("price-graph", "figure", allow_duplicate=True),
            Input(dbt.ThemeSwitchAIO.ids.switch('theme'), 'value'),
            prevent_initial_call=True)
  def update_figure_template(switch_on):
      template = pio.templates["minty"] if switch_on else pio.templates["minty_dark"]
      patch_figure = Patch()
      patch_figure["layout"]["template"] = template
      return patch_figure
#+end_src
**** Plot Tab Components
***** General Plot Components
This might have to change. Place the time and price rangeslider to
the Plot Tab and get rid of the rest of it.

Instead of having strike, vol, rate, etc. Inside the Options Tab we
create as many options as we want and then just include those in the
plot. So potentially we remove everything except the price and time
rangeslider. All we would keep is those two and the graph.
#+begin_src python
  component_price_rangeslider = dcc.RangeSlider(min=1, max=5000, count=1, value=[2000,3500], id='price-range', tooltip={'placement':'bottom', 'always_visible':True})
  component_time_rangeslider = dcc.RangeSlider(min=1, max=100, count=1, value=[1,90], id='time-range', tooltip={'placement':'bottom', 'always_visible':True})

  component_strike_price = dbc.Input(id='strike-price', type='number', placeholder="Strike", value=3000, inputMode='numeric', debounce=True)
  component_time = dbc.Input(id='amount-time', type='number', placeholder="Number of Days", value=7, inputMode='numeric', debounce=True)
  component_volatility = dbc.Input(id='volatility', type='number', placeholder="Volatility", value=70, inputMode='numeric', debounce=True)
  component_rate = dbc.Input(id='rate', type='number', placeholder="Rate", value=15, inputMode='numeric', debounce=True)
  component_dividend = dbc.Input(id='dividend', type='number', placeholder="Dividend", value=0.1, inputMode='numeric', debounce=True)
  component_option_type = dbc.RadioItems(id='option-type', options=['Put', 'Call'], value='Call', inline=False)

  component_graph = dcc.Graph(id="price-graph", responsive=True)
#+end_src
***** Plot Tab Callbacks
****** CANCELLED Plot Callbacks
CLOSED: [2024-01-15 Mon 21:35]
:PROPERTIES:
:header-args: :tangle no
:END:
#+begin_src python
  def create_option_dataframe(vals):
      price = np.linspace(*vals[0], 500)
      strike = vals[1]
      time_range = np.linspace(*vals[2],int(vals[7]),dtype=int)
      volatility = vals[3]/100
      rate = vals[4]/100
      dividend = vals[5]/100
      option_type = vals[6]
      if option_type.lower() == 'call':
          optionfn = options.Call().optionfn
      else:
          optionfn = options.Put().optionfn
      df = pd.DataFrame({f"{time:d}d": optionfn(price, strike, time, volatility, rate, dividend) for time in time_range}, index=price)
      return df

  @callback(Output("price-graph", "figure", allow_duplicate=True),
            [Input("{}".format(_), "value") for _ in ['price-range', 'strike-price', 'time-range', 'volatility', 'rate', 'dividend', 'option-type', 'amount-time']],
            prevent_initial_call='initial_duplicate')
  def render_plot(*vals):
      logger.info(f'render_plot input args: {vals}')
      df = create_option_dataframe(vals)
      fig = px.line(df, template="minty", labels='label')
      hover_template = "<br>".join(["Asset Price: $%{x}", "Option Price: $%{y}"]) + "<extra></extra>"
      fig.update_layout(yaxis={'type': 'log'}, xaxis_title="Asset Price ($)", yaxis_title="Option Price ($)", transition_duration=250)
      fig.update_legends(title={'text':'Days to Expiry'})
      return fig
#+end_src
****** New Plot Callbacks
#+begin_src python
def create_option_dataframe(price_range, strike, time_range, vol, rate, dividend, option_type, amount_time):
    price = np.linspace(*price_range, 500)
    time_range = np.linspace(*time_range,int(amount_time),dtype=int)
    if option_type.lower() == 'call':
        optionfn = options.Call().optionfn
    else:
        optionfn = options.Put().optionfn
    df = pd.DataFrame({f"{time:d}d": optionfn(price, strike, time, vol/100, rate/100, dividend/100) for time in time_range}, index=price)
    return df

@callback(Output("price-graph", "figure", allow_duplicate=True),
          [Input("price-range","value"),
           Input("strike-price","value"),
           Input("time-range","value"),
           Input("volatility","value"),
           Input("rate","value"),
           Input("dividend","value"),
           Input("option-type","value"),
           Input("amount-time","value"),
           Input(dbt.ThemeSwitchAIO.ids.switch('theme'), 'value')],
          prevent_initial_call='initial_duplicate')
def render_plot(price_range, strike, time_range, vol, rate, dividend, option_type, amount_time, theme):
    df = create_option_dataframe(price_range, strike, time_range, vol, rate,
                                 dividend, option_type, amount_time)
    fig = px.scatter(df, labels='label', template='minty' if theme else 'minty_dark')
    hover_template = "<br>".join(["Asset Price: $%{x}", "Option Price: $%{y}"]) + "<extra></extra>"
    fig.update_layout(xaxis_title="Asset Price ($)", yaxis_title="Option Price ($)", transition_duration=200)
    fig.update_legends(title={'text':'Days to Expiry'})
    return fig
#+end_src
****** Range Callbacks
#+begin_src python
  @callback([Output("time-range",'min'),
             Input("time-range",'value')])
  def update_time_rangeslider_min(child):
      return [max(0.5*child[0], 1)]

  @callback([Output("time-range",'max'),
             Input("time-range",'value')])
  def update_time_rangeslider_max(child):
      return [2*child[1]]

  @callback([Output("price-range",'min'),
             Input("price-range",'value')])
  def update_price_rangeslider_min(child):
      return [max(0.5*child[0], 1)]

  @callback([Output("price-range",'max'),
             Input("price-range",'value')])
  def update_price_rangeslider_max(child):
      return [2*child[1]]
#+end_src
**** ETHUSDT Tab Components
ETHUSDT candlestick plot. Gets an interval from user and displays
plot. Callback is needed to switch between different intervals.
#+begin_src python
  keys = {'1m':'1m', '1h':'1h', '4h':'4h', '1d':'1d', '1w':'1w', '1M':'1M'}
  ethusdt_interval_selector = dbc.RadioItems(id='ethusdt-interval-selector', inline=True,
                                             value='1d',
                                             options=['1m', '1h', '4h', '1d', '1w', '1M'])

  ethusdt_container = dbc.Container(children=[html.H4("ETHUSDT Binance"), 
                                              ethusdt_interval_selector,
                                              dcc.Graph(id='ethusdt-candlestick-plot', 
                                                        responsive=True)],
                                    fluid=True)

  tab_ethusdt = dbc.Tab(id='ethusdt-tab', label='ETHUSDT Graph', children=[ethusdt_container])

  @callback(output=Output('ethusdt-candlestick-plot', 'figure'),
            inputs=[Input('ethusdt-interval-selector', 'value'),
                    Input(dbt.ThemeSwitchAIO.ids.switch('theme'), 'value')])
  def display_eth_candlestick(value, theme):
      if not binance.ping():
          raise Exception("ERROR: Cannot contact binance. Try setting proxy")

      if value not in binance.INTERVALS.keys():
          raise Exception(f'INTERVAL ERROR: interval is not valid: {value}')
      ethusdt_df = binance.main(symbol='ETHUSDT', interval=value)
      config = config={'modeBarButtonsToAdd':
                       ['drawline','drawopenpath',
                        'drawclosedpath', 'drawcircle',
                        'drawrect'], 'scrollZoom': True,
                       'dragmode': 'pan', 'responsive': False,
                       'displaylogo': False}

      fig = go.Figure(go.Candlestick(x=ethusdt_df.index,
                                     open=ethusdt_df.Open,
                                     close=ethusdt_df.Close,
                                     low=ethusdt_df.Low,
                                     high=ethusdt_df.High))

      fig.update_layout(dragmode='pan', template='minty' if theme else
                        'minty_dark',
                        modebar_add=['drawline','drawopenpath', 'eraseshape',
                                     'drawclosedpath', 'drawcircle', 'drawrect'])

      #fig.layout.template = template='minty' if theme else 'minty_dark'
      return fig

  @callback(Output("ethusdt-candlestick-plot", "figure", allow_duplicate=True),
            Input(dbt.ThemeSwitchAIO.ids.switch('theme'), 'value'),
            prevent_initial_call=True)
  def update_figure_template(switch_on):
      template = pio.templates["minty"] if switch_on else pio.templates["minty_dark"]
      patch_figure = Patch()
      patch_figure["layout"]["template"] = template
      return patch_figure
#+end_src
**** BTCUSDT Tab Components
BTCUSDT candlestick plot. Gets an interval from user and displays
plot. Callback is needed to switch between different intervals.
#+begin_src python
  keys = {'1m':'1m', '1h':'1h', '4h':'4h', '1d':'1d', '1w':'1w', '1M':'1M'}
  btcusdt_interval_selector = dbc.RadioItems(id='btcusdt-interval-selector', inline=True,
                                             value='1d',
                                             options=['1m', '1h', '4h', '1d', '1w', '1M'])

  btcusdt_container = dbc.Container(children=[html.H4("BTCUSDT Binance"), 
                                              btcusdt_interval_selector,
                                              dcc.Graph(id='btcusdt-candlestick-plot', 
                                                        responsive=True)],
                                    fluid=True)

  tab_btcusdt = dbc.Tab(id='btcusdt-tab', label='BTCUSDT Graph', children=[btcusdt_container])

  @callback(Output('btcusdt-candlestick-plot', 'figure'),
            Input('btcusdt-interval-selector', 'value'),
            Input(dbt.ThemeSwitchAIO.ids.switch('theme'), 'value'))
  def display_btc_candlestick(value, theme):
      if not binance.ping():
          raise Exception("ERROR: Cannot contact binance. Try setting proxy")

      if value not in binance.INTERVALS.keys():
          raise Exception(f'INTERVAL ERROR: interval is not valid: {value}')
      btcusdt_df = binance.main(symbol='BTCUSDT', interval=value)
      fig = go.Figure(go.Candlestick(x=btcusdt_df.index,
                                     open=btcusdt_df.Open,
                                     close=btcusdt_df.Close,
                                     low=btcusdt_df.Low,
                                     high=btcusdt_df.High))
      fig.layout.template = template='minty' if theme else 'minty_dark'
      return fig

  @callback(Output("btcusdt-candlestick-plot", "figure", allow_duplicate=True),
            Input(dbt.ThemeSwitchAIO.ids.switch('theme'), 'value'),
            prevent_initial_call=True)
  def update_figure_template(switch_on):
      template = pio.templates["minty"] if switch_on else pio.templates["minty_dark"]
      patch_figure = Patch()
      patch_figure["layout"]["template"] = template
      return patch_figure
#+end_src
**** Option Tab Components
#+begin_src python
  options_container = dbc.Container(children=[
      dbc.Button("Add Option", id="add-option-btn", n_clicks=0),
      html.Div(id='container-div', children=[]),
      html.Div(id='container-output-div'),
  ], fluid=True)
#+end_src
***** Option Tab Callbacks
****** TODO Add/Delete New Options Callback
An option row should have Price, Strike, Time, Volatility, Rate,
Dividend, Option Type, and a Delete Button.

TODO: add some labeling using textbox labels in dbc or something.
#+begin_src python
  def make_new_option(n_clicks):
      logger.info(f'Making new option index={n_clicks}')
      return dbc.Container(children=[
          f"Option #{n_clicks}: ",
          dbc.Form(children=[
              dbc.Input(id={'type': 'price', "index": n_clicks}, persistence=True, persistence_type='memory', type='number', inputmode='numeric', placeholder='Price ($)', min=0),
              dbc.Input(id={'type': 'strike', "index": n_clicks}, persistence=True, persistence_type='memory', type='number', inputmode='numeric', placeholder='Strike ($)', min=0),
              dbc.Input(id={'type': 'time', "index": n_clicks}, persistence=True, persistence_type='memory', type='number', inputmode='numeric', placeholder='Time (Days)', min=0),
              dbc.Input(id={'type': 'vol', "index": n_clicks}, persistence=True, persistence_type='memory', type='number', inputmode='numeric', placeholder='Vol (%)', min=0),
              dbc.Input(id={'type': 'rate', "index": n_clicks}, persistence=True, persistence_type='memory', type='number', inputmode='numeric', placeholder='Rate (%)'),
              dbc.Input(id={'type': 'dividend', "index": n_clicks}, persistence=True, persistence_type='memory', type='number', inputmode='numeric', placeholder='Dividend (%)'),
              dbc.RadioItems(id={'type': 'option-type', 'index': n_clicks}, options=['Call', 'Put'], value='Call', inline=True),
          ], id={'type': 'option-form', 'index': n_clicks}),
          dbc.Textarea(id={'type': 'text-area', 'index': n_clicks}, readOnly=True, rows=1),
          dbc.Button(children="Delete Child", id={'type': 'delete', 'index': n_clicks}, value=n_clicks, type='button', active=True, size='sm'),
          html.P(),
      #], id={'type': 'option-row', 'index': n_clicks}, align='start')
      ], id={'type': 'option-container', 'index': n_clicks}, fluid=True)

  @callback(Output('container-div', 'children', allow_duplicate=True),
            Input('add-option-btn', 'n_clicks'),
            prevent_initial_call=True)
  def add_option(n_clicks):
      logger.info(f'add_option arg: {n_clicks}')
      patched_children = Patch()
      new_option = make_new_option(n_clicks)
      patched_children.append(new_option)
      return patched_children

  @callback(Output({'type': 'option-container', 'index': MATCH}, 'children'),
            [Input({'type': 'delete', 'index': MATCH}, 'n_clicks'),
             Input({'type': 'delete', 'index': MATCH}, 'value')],
            prevent_initial_call=True)
  def delete_option(n_clicks, value):
      logger.info(f'Clicked delete on option #{value}')
      return None
#+end_src
****** Update Options Callback
#+begin_src python
  @callback(Output({'type': 'text-area', 'index': MATCH}, 'value'),
            [Input({'type': 'price', 'index': MATCH}, 'value'),
             Input({'type': 'strike', 'index': MATCH}, 'value'),
             Input({'type': 'time', 'index': MATCH}, 'value'),
             Input({'type': 'vol', 'index': MATCH}, 'value'),
             Input({'type': 'rate', 'index': MATCH}, 'value'),
             Input({'type': 'dividend', 'index': MATCH}, 'value'),
             Input({'type': 'option-type', 'index': MATCH}, 'value')])
  def options_calculator(price, strike, time, vol, rate, dividend, option_type):
      if not all([price, strike, time, vol, rate, dividend]):
          return "Fill All Fields"
      if option_type.lower() == 'call':
          optionfn = options.Call().optionfn
      elif option_type.lower() == 'put':
          optionfn = options.Put().optionfn
      option_price = optionfn(price, strike, time, vol/100, rate/100, dividend/100)
      logger.info('(price,strike,time,vol,rate,dividend,option_type)={}'.format((price, strike, time, vol, rate, dividend, option_type)))
      logger.info(f'Options price={option_price}')
      return f'{option_price:.3g}'
#+end_src
**** Dash Tabs Components
Setting persistence on the tab keeps us in the correct tab we want.
#+begin_src python 
  tab_plot = dbc.Tab(id='plot-tab', label="Plot Tab", children=[
      dbc.Container(children=[
      html.P(),
      dbc.Row([component_price_rangeslider], justify='center'),
      html.P(),
      dbc.Row([component_time_rangeslider], justify='center'),
      html.P(),
      dbc.Row([
          dbc.Col(["Strike Price ($): ", component_strike_price]),
          dbc.Col(["Volatility (%): ", component_volatility]), 
          dbc.Col(["Rate (%): ", component_rate]), 
          dbc.Col(["Dividend (%): ", component_dividend]),
          dbc.Col(["# of Time Components", component_time]),
          dbc.Col([component_option_type], align='center')
      ], justify='center', align='center'),
      html.P(),
      dbc.Row(component_graph, justify='center', align='center')],
                    fluid=True)])

  tab_options = dbc.Tab(id='option-tab', label="Options Tab", children=[
      options_container])

  tabs = dbc.Tabs(id='tabs', children=[
      tab_options,
      tab_plot, tab_btcusdt, tab_ethusdt], persistence=True, persistence_type='memory')
#+end_src
**** App Layout
This stores the layout for the entire application. The classname
allows the theme changer to set it to dark mode or whatever other
theme.
#+begin_src python
  app.layout = dbc.Container(children=[
      dbc.Row(children=[color_mode_switch], justify='center'), 
      tabs
  ], fluid=True, className='m-4 dbc')
#+end_src
*** Dash Start
#+begin_src python
  def main(vals):
      component_price_rangeslider.value = vals.price_range
      component_time_rangeslider.max = vals.time
      component_strike_price.value = vals.strike
      component_volatility.value = vals.volatility
      component_rate.value = vals.rate
      component_dividend.value = vals.dividend
      component_option_type.value = 'Call' if vals.option_type == 'c' else 'Put'
      app.run(debug=vals.debug_mode, host='0.0.0.0', port=vals.server_port )
      return None

  if __name__ == '__main__':
      app.run(debug=True, host='0.0.0.0')
#+end_src
** Options Class
:PROPERTIES:
:header-args: :tangle options.py
:END:
*** Initialization
#+begin_src python
  import sympy
  from sympy import exp, oo, log, exp, sqrt, pi
  from sympy.abc import z,q,r,T,S,K,sigma,delta,gamma,rho,theta
  vega = sympy.symbols('vega')

  put = 'put'
  call = 'call'
#+end_src
*** Options and Greeks Definitions
#+begin_src python
  N = lambda x: (1/(2*pi)**0.5 * exp(-0.5*z**2)).integrate((z, -oo, x))
  d1 = (log(S/K) + (r - q + sigma**2 / 2) * (T/365)) / (sigma*(T/365)**0.5)
  d2 = (log(S/K) + (r - q - sigma**2 / 2) * (T/365)) / (sigma*(T/365)**0.5)

  calleq = S*exp(-q*T/365)*N(d1) - K*exp(-r*T/365)*N(d2)
  puteq = K*exp(-r*T/365)*N(-d2) - S*exp(-q*T/365)*N(-d1)
  callfn = sympy.lambdify((S,K,T,sigma,r,q), calleq)
  putfn = sympy.lambdify((S,K,T,sigma,r,q), puteq)

  deltaeq = sympy.diff(calleq, S)
  gammaeq = sympy.diff(deltaeq, S)
  thetaeq = sympy.diff(calleq, T)
  vegaeq = sympy.diff(calleq, sigma)
  rhoeq = sympy.diff(calleq, r)
  deltafn = sympy.lambdify((S,K,T,sigma,r,q), deltaeq)
  gammafn = sympy.lambdify((S,K,T,sigma,r,q), gammaeq)
  thetafn = sympy.lambdify((S,K,T,sigma,r,q), thetaeq)
  vegafn = sympy.lambdify((S,K,T,sigma,r,q), vegaeq)
  rhofn = sympy.lambdify((S,K,T,sigma,r,q), rhoeq)
#+end_src
*** Objects
**** Black Scholes Merton Class
#+begin_src python
  class BlackSholes:
      """Option Class. Give it PRICE STRIKE TIME VOL RATE DIVIDEND and optionally OPTION_TYPE."""
      def __init__(self, option_type = None):
          if option_type and isinstance(option_type, str) and option_type.lower() == put:
              self.option_type = 'put'
              self.optioneq = puteq
              self.optionfn = putfn
          else:
              self.option_type = call
              self.optioneq = calleq
              self.optionfn = callfn

          self.deltaeq = sympy.diff(self.optioneq, S)
          self.gammaeq = sympy.diff(self.deltaeq, S)
          self.thetaeq = sympy.diff(self.optioneq, T)
          self.vegaeq = sympy.diff(self.optioneq, sigma)
          self.rhoeq = sympy.diff(self.optioneq, r)

          self.deltafn = sympy.lambdify((S,K,T,sigma,r,q), self.deltaeq)
          self.gammafn = sympy.lambdify((S,K,T,sigma,r,q), self.gammaeq)
          self.thetafn = sympy.lambdify((S,K,T,sigma,r,q), self.thetaeq)
          self.vegafn = sympy.lambdify((S,K,T,sigma,r,q), self.vegaeq)
          self.rhofn = sympy.lambdify((S,K,T,sigma,r,q), self.rhoeq)
          return

      # def __eq__(self, other_option):
      #     if other_option and self and self.price == other_option.price and self.strike == other_option.strike and self.time == other_option.time and self.vol == other_option.vol and self.rate == other_option.rate and self.dividend == other_option.dividend and self.option_fn == other_option.option_fn:
      #         return True
      #     return False
      def greeks(self, *args):
          return {delta: self.deltafn(*args),
                  gamma: self.gammafn(*args),
                  theta: self.thetafn(*args),
                  vega: self.vegafn(*args),
                  rho: self.rhofn(*args)}

      def __repr__(self):
          #<__main__.Option object at 0x7f7dd5ab9050>
          # greeks_str = f"delta={self.delta:.2f} gamma={self.gamma:.6f} theta={self.theta:.2f} vega={self.vega:.2f} rho={self.rho:.2f}"
          # return f"<Option object Price={self.price} Strike={self.strike} Time={self.time} Vol={self.vol} Rate={self.rate} Dividend={self.dividend} Type={self.option_type} Option Price={self.option_price:.2f} Greeks={greeks_str}>"
          # return f"<Option object Price={self.price} Strike={self.strike} Time={self.time} Vol={self.vol} Rate={self.rate} Dividend={self.dividend} Type={self.option_type} Option Price={self.option_price:.2f}>"
          return f"<Option object Type={self.option_type}>"
#+end_src
**** Call and Put Classes
#+begin_src python
  class Put(BlackSholes):
      def __init__(self):
          super(Put, self).__init__('put')
          return

  class Call(BlackSholes):
      def __init__(self):
          super(Call, self).__init__('call')
          return
#+end_src
**** Option Class
#+begin_src python
  class Option(BlackSholes):
      """Documentation for Option
      """
      def __init__(self, args):
          super(Option, self).__init__()
          self.args = args
#+end_src
** Main File
:PROPERTIES:
:header-args: :tangle main.py
:END:
Everything is loaded and launched from this file.

This also gets all the arguments that are passed to the program.
#+begin_src python
  import argparse

  parser = argparse.ArgumentParser()
  parser.add_argument('--price-range', '-p',nargs=2, default=[3000,5000], type=float, help='Price Range. def 3000 5000')
  parser.add_argument('--strike', '-s', type=float, default=4500, help='Strike Price. Def 4500')
  parser.add_argument('--time', '-t', type=int, default=90, help='Days to Expiry. Def 90')
  parser.add_argument('--volatility', '-V', type=float, default=75, help='Volatility as percentage. Def 75')
  parser.add_argument('--rate', '-r', type=float, default=5, help='Risk Free Rate as percentage. Def 5')
  parser.add_argument('--dividend', '-d', type=float, default=0.1, help='Dividend as percentage. Def 0.1')
  parser.add_argument('--option-type', '-o', type=str, default='c', help='Option Type. Def c')
  parser.add_argument('--debug-mode','-D', action='store_true', help='Enable DEBUG mode so that program hot reloads when code is changed. Def Off')
  parser.add_argument('--server-port', '-P', type=int, default=8050, help='Set Port number for web host. Def 8050')
  parser.add_argument('--proxy', type=str, default=None, help='Proxy. Works by setting ALL_PROXY environment variable in the python program')

  args = parser.parse_args()

  if args.proxy:
      import os
      os.environ['ALL_PROXY'] = args.proxy

  if __name__ == '__main__':
      import plot
      plot.main(args)
#+end_src
